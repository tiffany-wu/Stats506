---
title: "Problem Set 2"
author: "Tiffany Wu"
format: 
  html:
    code-fold: true
    code-summary: "Show the code"
    embed-resources: true
editor: source
mainfont: Times New Roman
---
 
## Github Repo Link to Problem Set 1:
[https://github.com/tiffany-wu/Stats506/tree/main/PS2](https://github.com/tiffany-wu/Stats506/tree/main/PS2) 

## Problem 1 - Dice Game
Let’s play a dice game. It costs $2 to play. You roll a single 6-sided die.

* On a roll of 3 or 5, you win twice your roll.
* On any other roll, you lose.

The input and output should be:

* Input: The number of dice to roll.
* Output: Total winnings

### Version 1: Loop
*set seed inside or outside funciton?*

Take in seed to set inside function. Set right before you need to randomize.

Take in ARGUMENT FOR SEED.

```{r}
# Version 1: Using a loop

#' Play Dice Game - Loop Version
#'
#' This function simulates a dice game using a loop. It costs $2 to play each round, 
#' and you roll a single 6-sided die. If the roll is 3 or 5, you win twice your roll; 
#' otherwise, you lose $2.
#'
#' @param n Positive integer. The number of dice rolls (or rounds) to simulate.
#' @param seed Optional. Numeric. The seed for the random number generator.
#'
#' @return Numeric. The total winnings (or losses) after `n` rolls.
#' 
#'
#' @examples
#' play_dice_loop(10, seed = 123) # Example with 10 rolls with seed of 123
#'
#' @export
#' 
play_dice_loop <- function(n, seed = NULL) {
  
  # Input sanitization -- make sure n is a positive integer
  # Double bars is logical OR operator, returns TRUE if at least one condition is TRUE
  if (!is.numeric(n) || n <= 0 || n != as.integer(n)) {
    stop("Error: 'n' must be a positive integer.")
  }
  
  # Input sanitization -- make sure if seed is provided it's numeric
  if (!is.null(seed) && !is.numeric(seed)) {
    stop("Error: 'seed' must be numeric.")
  }
  
  # Set seed if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Setting seed for reproducibility manually
 # set.seed(285) 
  
  # Initiate winnings with 0 dollars
  winnings <- 0
  
  for (i in 1:n) {
    
    # Roll a 6-sided die-- use sample instead of runif for whole values 
    roll <- sample(1:6, 1, replace = TRUE)
#   print(roll)
    
    # If you get 3 or 5, you win twice your roll (minus the 2 it cost to play)
    if (roll == 3 || roll == 5) {
      winnings <- winnings + 2 * roll - 2
#      print(winnings)
    } else {
      # Else you lose the 2 dollars it cost to play
      winnings <- winnings - 2
 #     print(winnings)
    }
  }
  return(winnings)
}

play_dice_loop(3, seed = 5)
play_dice_loop(30000)

```

### Version 2: Vectorized
```{r}
#' Play Dice Game - Vectorized Version
#'
#' This function simulates a dice game using vectorized functions in R. It costs $2 to play each round, 
#' and you roll a single 6-sided die. If the roll is 3 or 5, you win twice your roll; 
#' otherwise, you lose $2.
#'
#' @param n Positive integer. The number of dice rolls (or rounds) to simulate.
#' @param seed Optional. Numeric. The seed for the random number generator.
#' 
#' @return Numeric. The total winnings (or losses) after `n` rolls.
#' 
#' @examples
#' play_dice_vector(10) # Example with 10 rolls
#'
#' @export
play_dice_vector <- function(n, seed = NULL) {
  
  # Input sanitization -- make sure n is a positive integer
  if (!is.numeric(n) || n <= 0 || n != as.integer(n)) {
    stop("Error: 'n' must be a positive integer.")
  }
  
  # Input sanitization -- make sure seed is numeric if provided
  if (!is.null(seed) && !is.numeric(seed)) {
    stop("Error: 'seed' must be numeric.")
  }
  
  # Set seed if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Roll n times using vectorized function
  rolls <- sample(1:6, n, replace = TRUE)
  
  # Calculate winnings: if roll is 3 or 5, you win twice your roll, otherwise lose $2
  winnings <- sum(ifelse(rolls == 3 | rolls == 5, 2 * rolls - 2, -2))
  
  return(winnings)
}


play_dice_vector(3, seed = 89034892)
```

### Version 3: Table
```{r}
#' Play Dice Game - Table Version
#'
#' This function simulates a dice game by rolling all the dice at once and collapsing the die rolls into a table.
#' It costs $2 to play each round, and you roll a single 6-sided die. If the roll is 3 or 5, you win twice your roll; 
#' otherwise, you lose $2.
#'
#' @param n Positive integer. The number of dice rolls (or rounds) to simulate.
#' @param seed Optional. Numeric. The seed for the random number generator.
#'  
#' @return Numeric. The total winnings (or losses) after `n` rolls.
#' 
#' @examples
#' play_dice_table(10) # Example with 10 rolls
#'
#' @export
play_dice_table <- function(n, seed = NULL) {
  
  # Input sanitization -- make sure n is a positive integer
  if (!is.numeric(n) || n <= 0 || n != as.integer(n)) {
    stop("Error: 'n' must be a positive integer.")
  }
  
  # Input sanitization -- make sure seed is numeric if provided
  if (!is.null(seed) && !is.numeric(seed)) {
    stop("Error: 'seed' must be numeric.")
  }
  
  # Set seed if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Roll n times and create a frequency table of results
  rolls <- sample(1:6, n, replace = TRUE)
 # print(rolls)
  roll_counts <-table(factor(rolls, levels = 1:6)) # Use factors to make sure all dice values appear in table (Source: ChatGPT)
 # print(roll_counts)
  
  # Initialize winnings
  winnings <- 0
  
  # Calculate winnings for 3s and 5s-- adjust indexing safely
  winnings <- winnings + sum(roll_counts[c('3', '5')] * as.numeric(names(roll_counts[c('3', '5')])) * 2, na.rm = TRUE)
  
  # Subtract the cost of playing (2 dollars per roll) from total winnings
  winnings <- winnings - (sum(roll_counts[c('3', '5')]) * 2)
  
  # Calculate losses for other rolls
  winnings <- winnings - sum(roll_counts[c('1', '2', '4', '6')] * 2, na.rm = TRUE)
  
  return(winnings)
}

play_dice_table(3)
```

### Version 4: apply function

```{r}
#' Play Dice Game - Apply Function Version
#'
#' This function simulates a dice game using an apply function. It costs $2 to play each round, 
#' and you roll a single 6-sided die. If the roll is 3 or 5, you win twice your roll; 
#' otherwise, you lose $2.
#'
#' @param n Positive integer. The number of dice rolls (or rounds) to simulate.
#' @param seed Optional. Numeric. The seed for the random number generator.
#'
#' @return Numeric. The total winnings (or losses) after `n` rolls.
#' 
#' @examples
#' play_dice_apply(10) # Example with 10 rolls
#'
#' @export
play_dice_apply <- function(n, seed = NULL) {
  
  # Input sanitization -- make sure n is a positive integer
  if (!is.numeric(n) || n <= 0 || n != as.integer(n)) {
    stop("Error: 'n' must be a positive integer.")
  }
  
  # Input sanitization -- make sure seed is numeric if provided
  if (!is.null(seed) && !is.numeric(seed)) {
    stop("Error: 'seed' must be numeric.")
  }
  
  # Set seed if provided
  if (!is.null(seed)) {
    set.seed(seed)
  }
  
  # Use sapply to roll the dice n times
  rolls <- sapply(1:n, function(x) sample(1:6, 1, replace = TRUE))
  
  # Calculate winnings using apply-like structure
  winnings <- sum(ifelse(rolls == 3 | rolls == 5, 2 * rolls - 2, -2))
  
  return(winnings)
}

play_dice_apply(3)
```

## b. Demonstrate that all versions work. Do so by running each a few times, once with an input a 3, and once with an input of 3,000.
```{r}
# Loop
play_dice_loop(3)
play_dice_loop(3000)

# Table
play_dice_table(3)
play_dice_table(3000)

# Vector
play_dice_vector(3)
play_dice_vector(3000)

# Apply
play_dice_apply(3)
play_dice_apply(3000)


```

## c. Demonstrate that the four versions give the same result. Test with inputs 3 and 3,000. (You will need to add a way to control the randomization.)

```{r}
# Loop
play_dice_loop(3, seed = 285)
play_dice_loop(3000, seed = 285)

# Table
play_dice_table(3, seed = 285)
play_dice_table(3000, seed = 285)

# Vector
play_dice_vector(3, seed = 285)
play_dice_vector(3000, seed = 285)

# Apply
play_dice_apply(3, seed = 285)
play_dice_apply(3000, seed = 285)


```

## d. Use the microbenchmark package to clearly demonstrate the speed of the implementations. Compare performance with a low input (1,000) and a large input (100,000). Discuss the results.

```{r}
library(microbenchmark)

# Run the microbenchmark comparison
benchmark_results <- microbenchmark(
  loop_1000 = play_dice_loop(1000),
  vector_1000 = play_dice_vector(1000),
  table_1000 = play_dice_table(1000),
  apply_1000 = play_dice_apply(1000),
  loop_100000 = play_dice_loop(100000),
  vector_100000 = play_dice_vector(100000),
  table_100000 = play_dice_table(100000),
  apply_100000 = play_dice_apply(100000),
  times = 10
)

# Print and plot benchmark results
print(benchmark_results)

boxplot(benchmark_results, main = "Performance Comparison of Dice Game Implementations",
        ylab = "Time (milliseconds)", las = 2)

```
Vectorized Approach (vector_1000 and vector_100000): This version is typically the fastest because R is optimized for vectorized operations. It performs all calculations in a single step without needing to iterate over elements, making it highly efficient, especially for large inputs.

Loop Approach (loop_1000 and loop_100000): This implementation is generally slower, especially for large inputs. The loop explicitly iterates over each dice roll, which adds overhead. The performance gap widens as the input size increases.

Table Approach (table_1000 and table_100000): The use of table() with factors helps avoid indexing issues, but this approach is still slower than the vectorized version because it involves extra steps to tabulate counts and handle NA values.

Apply Function (apply_1000 and apply_100000): This version is slightly more efficient than the loop because it leverages sapply, which is optimized but still involves implicit looping. It performs better than the plain loop but is generally slower than direct vectorization.

Input Size Impact:

For 1,000 rolls, all implementations complete relatively quickly, though the differences are still noticeable. The vectorized approach is consistently faster, followed by apply, table, and loop.
For 100,000 rolls, the differences become much more pronounced. The vectorized version significantly outperforms others, completing the task in much less time compared to the loop-based approaches, which slow down considerably as the number of iterations increases.
Conclusion:

Vectorization is the clear winner for performance in R, leveraging the language's strengths in handling large data efficiently.
Loops and apply functions provide flexibility but come at a performance cost, particularly for larger inputs.
The table approach, while handling edge cases well, introduces overhead due to frequency tabulation and indexing adjustments.

## e. Do you think this is a fair game? Defend your decision with evidence based upon a Monte Carlo simulation.

# Q
*Just using play_dice_vector okay since all results are the same??*

Monte Carlo Simulation
We'll use a Monte Carlo simulation to estimate the expected value of the game by running a large number of trials. This approach will help us determine whether the player wins or loses on average.

Steps:
Simulate a large number of games (e.g., 100,000).
For each game, simulate the dice rolls and calculate the winnings.
Compute the average winnings across all simulations.
If the average winnings are negative, the game is unfair.

# Q
*WHAT NUMBER GOES INSIDE THE PLAY_DICE_VECTOR FUNCTION???????*

```{r}
# Monte Carlo simulation to evaluate game fairness
simulate_game <- function(n_sim) {
 # set.seed(285)
  
  # Pick a random number (integer) of times to roll the dice in each game
 # runs <- sample(100, 1) # FIX THIS AT SOMETHING, RUN WITH DIFFERENT RESULTS. DON'T SET SEED FOR THIS TIME.
  
  # Replicate the game n_sim (100000) times
  winnings <- replicate(n_sim, play_dice_vector(100)) # Using vectorized version for speed
  
  mean_winnings <- mean(winnings)
  
  return(mean_winnings)
}

# Simulate 100,000 games
set.seed(285)
average_winnings <- simulate_game(100000)
print(average_winnings)

# Assess fairness
if (average_winnings < 0) {
  print("The game is not fair; on average, you lose money.")
} else if (average_winnings > 0) {
  print("The game is favorable; on average, you win money.")
} else {
  print("The game is fair; on average, you break even.")
}

```

## Problem 2 - Linear Regression

Download the cars data set available at https://corgis-edu.github.io/corgis/csv/cars/. The goal is to examine the relationship between torque and highway gas mileage.
```{r}
library(readr)
library(tidyverse)
cars <- read_csv("cars.csv")
```

### a. The names of the variables in this data are way too long. Rename the columns of the data to more reasonable lengths.
```{r}
# What are the current names?
names(cars)

# Rename columns to shorter, more readable names
cars2 <- cars %>%
  rename(
    height = "Dimensions.Height",
    length_dim = "Dimensions.Length", # Because length is also a command in R
    width = "Dimensions.Width",
    driveline = "Engine Information.Driveline",
    engine_type = "Engine Information.Engine Type",
    hybrid = "Engine Information.Hybrid",
    gears = "Engine Information.Number of Forward Gears",
    transmission = "Engine Information.Transmission",
    city_mpg = "Fuel Information.City mpg",
    fuel_type = "Fuel Information.Fuel Type",
    highway_mpg = "Fuel Information.Highway mpg",
    classification = "Identification.Classification",
    id = "Identification.ID",
    make = "Identification.Make",
    model_year = "Identification.Model Year",
    year = "Identification.Year",
    horsepower = "Engine Information.Engine Statistics.Horsepower",
    torque = "Engine Information.Engine Statistics.Torque"
  )

```

### b. Restrict the data to cars whose Fuel Type is “Gasoline”.

```{r}
# Filter
gasoline_cars <- cars2 %>%
  filter(fuel_type == "Gasoline")
```

### Examine the distribution of highway gas mileage. Consider whether a transformation could be used. If so, generate the transformed variable and use this variable going forward. If not, provide a short justification.

Based on the histogram and boxplot below, we can see that the data is right-skewed, with one car that has an mpg of 223 skewing the data.

*GETTING RID OF THE OUTLIER IS THE SOLUTION?*
```{r}
# Examine distribution
ggplot(gasoline_cars, aes(x = highway_mpg)) +
  geom_histogram(bins = 30, color = "black", fill = "skyblue") +
  labs(
    title = "Distribution of Highway Gas Mileage",
    x = "Highway MPG",
    y = "Frequency"
  ) +
  theme_minimal()

ggplot(gasoline_cars, aes(y = highway_mpg)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  labs(
    title = "Box Plot of Highway Gas Mileage",
    y = "Highway MPG"
  ) +
  theme_minimal()

# What is the max? This is an outlier
summary(gasoline_cars$highway_mpg) # 223

# Get skewness/kurtosis
library(psych)
psych::describe(gasoline_cars$highway_mpg)


# If we get rid of the outlier, it's better.
gasoline_cars2 <- gasoline_cars %>% filter(highway_mpg <100)
ggplot(g, aes(x = highway_mpg)) +
  geom_histogram(bins = 30, color = "black", fill = "skyblue") +
  labs(
    title = "Distribution of Highway Gas Mileage",
    x = "Highway MPG",
    y = "Frequency"
  ) +
  theme_minimal()

psych::describe(gasoline_cars2$highway_mpg) # if get rid of outlier, skewness is now <1, at 0.46
```
The skewness() function (from the e1071 package) calculates the skewness. A skewness value > |1| suggests significant skewness.
Transformation:
If skewness is high, apply a log transformation and visualize the transformed data.
If skewness is low or data is approximately normal, no transformation is needed.

### d. Fit a linear regression model predicting MPG on the highway. The predictor of interest is torque. Control for:

The horsepower of the engine
All three dimensions of the car
The year the car was released, as a categorical variable.

Briefly discuss the estimated relationship between torque and highway MPG. Be precise about the interpretation of the estimated coefficient.

```{r}
library(lmtest)

# Make year a categorical variable
gasoline_cars2 <- gasoline_cars2 %>%
  mutate(year = as.factor(year))

# Regression
reg1 <- lm(highway_mpg ~ torque + horsepower + height + length_dim + width + year, 
                   data = gasoline_cars2)

summary(reg1)

```

### e. It seems reasonable that there may be an interaction between torque and horsepower. Refit the model (with lm) and generate an interaction plot, showing how the relationship between torque and MPG changes as horsepower changes. Choose reasonable values of torque, and show lines for three different reasonable values of horsepower.

```{r}
library(emmeans)
# Refit model with interaction
interaction_model <- lm(highway_mpg ~ torque * horsepower + height + length_dim + width + year, 
                        data = gasoline_cars2)

summary(interaction_model)

# Use `emmeans` to calculate estimated marginal means for the interaction between torque and horsepower
# Choose reasonable values for torque and specify three values of horsepower for the plot
torque_values <- seq(90, 770, by = 20) 
horsepower_values <- quantile(gasoline_cars2$horsepower, probs = c(0.25, 0.5, 0.75), na.rm = TRUE)

# Generate the estimated marginal means
em_interaction <- emmeans(interaction_model, ~ torque * horsepower, 
                          at = list(torque = torque_values, horsepower = horsepower_values))

# Plot the interaction effect using `emmip()`
emmip(em_interaction, horsepower ~ torque, 
      at = list(torque = torque_values, horsepower = horsepower_values),
      xlab = "Torque (lb-ft)", ylab = "Estimated Highway MPG", 
      main = "Interaction Plot: Torque and Horsepower on Highway MPG",
      lines = TRUE)
```


### f. Calculate from d. manually (without using lm) by first creating a proper design matrix, then using matrix algebra to estimate. Confirm that you get the same result as lm did prior.

```{r}
# Get the design matrix

head(model.matrix(highway_mpg ~ torque + horsepower + height + length_dim + width + year, data = gasoline_cars2))

cars_mat <- model.matrix(highway_mpg ~ torque + horsepower + height + length_dim + width + year, data = gasoline_cars2)

# Remove the 'torque' column since that's the y vector
X_mat <- cars_mat

# y matrix
y_mat <- gasoline_cars2$highway_mpg

# Check the dimensions to ensure compatibility
cat("Dimensions of X_mat:", dim(X_mat), "\n")
cat("Length of y_mat:", length(y_mat), "\n")

# Matrix algebra
# Manually calculate the regression coefficients using matrix algebra
# Formula: beta_hat = (X'X)^(-1) X'y
beta_hat <- solve(t(X_mat) %*% X_mat) %*% t(X_mat) %*% y_mat

print(beta_hat)

# Check against regression
coefficients(reg1)
lm_coefs <- coefficients(reg1)

# Equal?
# Remove names from both vectors to avoid comparison issues with names
beta_hat_no_names <- as.vector(beta_hat)
lm_coefs_no_names <- as.vector(lm_coefs)

all.equal(beta_hat_no_names, lm_coefs_no_names)
```


